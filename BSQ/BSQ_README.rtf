{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww14140\viewh12320\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 ============================================================\
BSQ PROJECT EXPLANATION AND DEFENSE GUIDE\
============================================================\
\
------------------------------------------------------------\
1) THE ASSIGNMENT (WHAT BSQ WANTS)\
------------------------------------------------------------\
Goal:\
Write a C program called bsq that reads one or more map files (or stdin if no file is provided).\
Each map represents an area made of empty spaces and obstacles.\
Your program must find the largest possible square of empty spaces and mark it with a special character.\
\
Input:\
- One or more files passed as arguments, or standard input (stdin) if no argument is given.\
\
Output:\
- Same map, but the largest empty square replaced with the "full" character.\
\
Rules:\
- If there are multiple possible squares, choose the one closest to the top, then the one closest to the left.\
- Must compile with:\
    cc -Wall -Wextra -Werror\
- Allowed system calls:\
    open, close, read, write, malloc, free, exit\
- Program name: bsq\
- Makefile required (must not relink)\
- Norminette rules apply (\uc0\u8804 25 lines per function, \u8804 4 params, \u8804 5 local vars)\
- On invalid input, print: map error\\n\
\
------------------------------------------------------------\
2) THE SOLUTION (YOUR TEAM\'92S APPROACH)\
------------------------------------------------------------\
Overall concept:\
The program reads a map, parses it, validates it, builds a 2D representation in memory,\
and finds the biggest square of empty cells that does not intersect any obstacle.\
\
Implementation outline:\
1. main.c handles arguments and calls map readers.\
2. read_map.c loads the file and concatenates its content into a single string.\
3. process_input.c splits the string into header and map data,\
   then validates and converts it into a structured t_map.\
4. solve.c and scan_grid.c analyze the grid to find the largest empty square.\
5. print_grid.c prints the updated map to stdout.\
6. util_1.c provides helper functions (ft_putstr, ft_atoi, etc.)\
\
------------------------------------------------------------\
3) EACH FILE AND ITS ROLE\
------------------------------------------------------------\
main.c\
-------\
- Entry point.\
- If no arguments: read from stdin (file descriptor 0).\
- If arguments: loop through files, process each with ft_open_map(), print newline between results.\
\
read_map.c\
-----------\
Functions:\
- ft_open_map():\
  Opens the file; prints "map error" if cannot open.\
- ft_read_map():\
  Reads file into a single large string buffer, appending chunks from read().\
- append_content() and cat_content():\
  Handle dynamic memory resizing for reading file content.\
\
process_input.c\
----------------\
Functions:\
- ft_process_header():\
  Reads header line (e.g. 9.ox), validates distinct characters, sets map rows and char types.\
- ft_map_row_init():\
  Allocates rows for map->map and sets column count.\
- ft_process_map_row():\
  Validates each row: same length, valid chars (empty or obstacle only).\
- ft_extract_map():\
  Combines parsing and validation to create the full t_map structure.\
- ft_process_map():\
  Orchestrates full process: extract, validate, solve, print, free memory.\
\
solve.c\
--------\
Functions:\
- solve_bsq():\
  Creates a t_sol struct, initializes coordinates and size.\
  Calls scan_grid() to find the largest square.\
  Calls fill_bsq() to fill the identified square.\
- fill_bsq():\
  Overwrites empty cells with the full character in the found square.\
\
scan_grid.c\
------------\
Functions:\
- scan_r_c():\
  Checks the new bottom row and right column of a growing square for obstacles.\
- get_bsq_by_pos():\
  Expands the square from (r,c) until it hits an obstacle or the edge.\
- scan_grid():\
  Loops through every (r,c), calculates largest possible square at each, and updates t_sol if larger.\
\
print_grid.c\
-------------\
- print_grid():\
  Loops through each row and prints it followed by a newline.\
\
util_1.c\
---------\
Functions:\
- ft_putstr():\
  Writes string to stdout.\
- ft_atoi():\
  Converts string to integer.\
- ft_strlen_d():\
  Returns length of string up to a given delimiter (used for detecting newline).\
- ft_free_map():\
  Frees all map memory including each row.\
\
------------------------------------------------------------\
4) FUNCTION FLOW (CALL ORDER)\
------------------------------------------------------------\
main()\
\uc0\u9474 \

\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_open_map(file)\
\uc0\u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  open()\
\uc0\u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_read_map(fd)\
\uc0\u9474      \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  read()\
\uc0\u9474      \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  append_content()\
\uc0\u9474      \u9474      \u9492 \u9472 \u9472  ft_process_map(raw_map)\
\uc0\u9474      \u9474            
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_extract_map()\
\uc0\u9474      \u9474            \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_process_header()\
\uc0\u9474      \u9474            \u9474      \u9492 \u9472 \u9472  ft_process_map_row()\
\uc0\u9474      \u9474            
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  solve_bsq()\
\uc0\u9474      \u9474            \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  scan_grid()\
\uc0\u9474      \u9474            \u9474      \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  get_bsq_by_pos()\
\uc0\u9474      \u9474            \u9474      \u9474      \u9474      \u9492 \u9472 \u9472  scan_r_c()\
\uc0\u9474      \u9474            \u9474      \u9492 \u9472 \u9472  fill_bsq()\
\uc0\u9474      \u9474            
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  print_grid()\
\uc0\u9474      \u9474            \u9492 \u9472 \u9472  ft_free_map()\
\uc0\u9474      \u9492 \u9472 \u9472  close()\
\uc0\u9492 \u9472 \u9472  Repeat for each file argument if any\
\
------------------------------------------------------------\
5) STEP BY STEP PROCESS\
------------------------------------------------------------\
1. Program starts in main().\
   - If no args: reads from stdin (fd 0).\
   - If args: loops through files and calls ft_open_map().\
\
2. ft_open_map():\
   - Opens file descriptor.\
   - On success: calls ft_read_map(fd).\
   - On failure: prints "map error" and returns.\
\
3. ft_read_map():\
   - Reads content using read() and appends into one raw_map string.\
   - Calls ft_process_map(raw_map) when complete.\
\
4. ft_process_map():\
   - Extracts map header and rows.\
   - Validates all lines (consistent width, valid chars, correct row count).\
   - On error: prints "map error".\
   - On success: calls solve_bsq(map).\
\
5. solve_bsq():\
   - Allocates t_sol structure to store best square.\
   - Calls scan_grid() to find the biggest square.\
   - Calls fill_bsq() to replace characters in that area.\
\
6. print_grid():\
   - Prints the completed map row by row to stdout.\
\
7. ft_free_map():\
   - Frees all allocated memory before returning.\
\
------------------------------------------------------------\
6) LIKELY EVALUATION QUESTIONS (AND ANSWERS)\
------------------------------------------------------------\
Q: Explain the map format.\
A: The first line contains the row count followed by three characters: empty, obstacle, and full.\
   Example: "9.ox" = 9 rows, '.' empty, 'o' obstacle, 'x' full.\
\
Q: How do you validate the map?\
A: We check header format, ensure all lines are same length, all characters are valid, and rows match count.\
\
Q: How do you find the largest square?\
A: For each (r,c), expand square until an obstacle or edge is hit.\
   Compare with current max size and update if larger.\
\
Q: What is the algorithm complexity?\
A: Roughly O(R * C * S) where S = smallest of row/col count.\
   Acceptable for small/medium maps.\
\
Q: Why not dynamic programming?\
A: Brute-force is simpler and clear under Norm constraints.\
\
Q: How do you break ties?\
A: Scan order ensures top-to-bottom, left-to-right priority.\
\
Q: Where could segfaults happen?\
A: During malloc failures or invalid indices.\
   We check allocations and validate inputs to prevent these.\
\
Q: How do you free memory?\
A: ft_free_map() frees each row and the overall map array.\
\
------------------------------------------------------------\
7) MINIMAL TEST SET YOU CAN DEMO FAST\
------------------------------------------------------------\
# OK map with a clear 3x3\
cat > ok1.map << 'EOF'\
5.ox\
.....\
..o..\
.....\
.o...\
.....\
EOF\
\
# Single cell row\
cat > tiny.map << 'EOF'\
1.ox\
.\
EOF\
\
# Bad header (non-number)\
cat > bad_header.map << 'EOF'\
x.ox\
.....\
EOF\
\
# Bad char in data\
cat > bad_char.map << 'EOF'\
3.ox\
..a\
...\
...\
EOF\
\
make\
./bsq ok1.map\
./bsq ok1.map bad_char.map tiny.map\
cat ok1.map | ./bsq\
\
\
============================================================\
42 C PISCINE FINAL PROJECT: BSQ (Biggest Square)\
============================================================\
\
------------------------------------------------------------\
1. PROJECT OVERVIEW\
------------------------------------------------------------\
Program name: bsq\
Goal: Find and print the largest possible square of empty spaces in a map, avoiding obstacles.\
Input: One or more files (or standard input if no file given)\
Output: The same map with the largest square replaced by the \'93full\'94 character\
Error output: "map error" followed by a newline\
\
Allowed functions: open, close, read, write, malloc, free, exit\
Compiler flags: -Wall -Wextra -Werror\
Makefile: Must exist and must not relink\
Norm: Strict (25-line function limit, 4 parameters max, 5 local variables max)\
\
------------------------------------------------------------\
2. MAP FORMAT\
------------------------------------------------------------\
Each file contains:\
1. A header line: <number_of_rows><empty><obstacle><full>\
   Example: 9.ox\
   Meaning: 9 rows, '.' = empty, 'o' = obstacle, 'x' = full\
\
2. A grid of rows containing only empty and obstacle characters.\
\
Validation rules:\
- All rows must have equal length.\
- Only empty and obstacle characters are allowed.\
- The three map characters must be distinct and printable.\
- Row count must match the declared number.\
\
Example valid map:\
5.ox\
.....\
..o..\
.....\
.o...\
.....\
\
Example invalid maps:\
x.ox        (non-numeric row count)\
3.ox\
..a\
...\
...          (invalid character 'a')\
3.ox\
.....\
....\
.....        (unequal line lengths)\
\
------------------------------------------------------------\
3. EXECUTION FLOW\
------------------------------------------------------------\
Overall pipeline:\
\
main.c\
  -> read_map.c: read the file into a single string\
  -> process_input.c: parse header, validate, and build t_map\
  -> solve.c: allocate t_sol, find largest square, fill map\
  -> print_grid.c: print the final map\
  -> util_1.c: free memory and utility functions\
\
------------------------------------------------------------\
4. CORE DATA STRUCTURES\
------------------------------------------------------------\
\
typedef struct s_map_data \{\
    int   row;\
    int   column;\
    char  empty;\
    char  obstacle;\
    char  full;\
    char **map;\
\} t_map;\
\
typedef struct s_sol_data \{\
    int   r;\
    int   c;\
    char  size;\
\} t_sol;\
\
t_map represents the parsed map.\
t_sol represents the best (largest) square found.\
\
------------------------------------------------------------\
5. FILE-BY-FILE EXPLANATION\
------------------------------------------------------------\
\
main.c\
--------\
Purpose: Entry point; handles arguments.\
- If no arguments: reads from stdin (fd 0).\
- If arguments: loops over each file and calls ft_open_map().\
- Prints a blank line between multiple map outputs.\
\
read_map.c\
------------\
Functions:\
- ft_open_map(char *map_file)\
  Opens file, prints "map error" if open fails, then calls ft_read_map().\
- ft_read_map(int fd)\
  Reads the file using read(), appends chunks into one big string, then calls ft_process_map().\
- append_content() and cat_content()\
  Expand buffers and join partial reads safely.\
\
process_input.c\
----------------\
Functions:\
- ft_process_header():\
  Parses the first line (header), validates that the last three characters are distinct,\
  sets row count, empty, obstacle, and full characters.\
- ft_map_row_init():\
  Allocates space for row pointers and sets column count.\
- ft_process_map_row():\
  Copies one line of map data, checks valid characters and consistent width.\
- ft_extract_map():\
  Parses the entire raw map string line by line into t_map.\
- ft_process_map():\
  Orchestrates everything: parses, validates, solves, prints, and frees map.\
\
solve.c\
--------\
Functions:\
- solve_bsq():\
  Allocates a t_sol struct, initializes it, calls scan_grid() to find the largest square,\
  then calls fill_bsq() to fill it.\
- fill_bsq():\
  Fills all cells in the best square with the \'93full\'94 character.\
\
scan_grid.c\
------------\
Functions:\
- scan_grid():\
  Iterates through all coordinates (r, c) of the map.\
  For each cell, calls get_bsq_by_pos() to determine maximum possible square size.\
- get_bsq_by_pos():\
  Tries to expand the square from position (r, c) until hitting an obstacle or edge.\
- scan_r_c():\
  Checks the new bottom row and right column of the current expanding square for obstacles.\
  \
This is a brute-force scanning method (O(n\'b3)) but sufficient for normal map sizes.\
\
print_grid.c\
-------------\
- print_grid():\
  Prints the map row by row, followed by newline.\
\
util_1.c\
---------\
Functions:\
- ft_putstr(): Writes a string to stdout.\
- ft_atoi(): Converts a string to integer.\
- ft_strlen_d(): Returns length until a delimiter (used to detect newline).\
- ft_free_map(): Frees all memory for map and rows.\
\
------------------------------------------------------------\
6. FUNCTION CALL CHAIN\
------------------------------------------------------------\
main()\
\uc0\u9474 \

\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_open_map(file)\
\uc0\u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  open()\
\uc0\u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_read_map(fd)\
\uc0\u9474      \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  read()\
\uc0\u9474      \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  append_content()\
\uc0\u9474      \u9474      \u9492 \u9472 \u9472  ft_process_map(raw_map)\
\uc0\u9474      \u9474            
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_extract_map()\
\uc0\u9474      \u9474            \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  ft_process_header()\
\uc0\u9474      \u9474            \u9474      \u9492 \u9472 \u9472  ft_process_map_row()\
\uc0\u9474      \u9474            
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  solve_bsq()\
\uc0\u9474      \u9474            \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  scan_grid()\
\uc0\u9474      \u9474            \u9474      \u9474      
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  get_bsq_by_pos()\
\uc0\u9474      \u9474            \u9474      \u9474      \u9474      \u9492 \u9472 \u9472  scan_r_c()\
\uc0\u9474      \u9474            \u9474      \u9492 \u9472 \u9472  fill_bsq()\
\uc0\u9474      \u9474            
\f1 \'a9\'c0
\f0 \uc0\u9472 \u9472  print_grid()\
\uc0\u9474      \u9474            \u9492 \u9472 \u9472  ft_free_map()\
\uc0\u9474      \u9492 \u9472 \u9472  close()\
\uc0\u9492 \u9472 \u9472  repeat for next file if any\
\
------------------------------------------------------------\
7. LOGIC FLOW (STEP BY STEP)\
------------------------------------------------------------\
1. Read map file into one string.\
2. Parse header (row count, empty, obstacle, full).\
3. Validate and build 2D char array (map->map).\
4. Scan all cells and find largest empty square.\
5. Fill that square with full character.\
6. Print the modified map.\
7. Free all allocated memory.\
\
------------------------------------------------------------\
8. ERROR HANDLING\
------------------------------------------------------------\
Error conditions and responses:\
\
Invalid header line ............ "map error"\
Non-numeric row count .......... "map error"\
Duplicate header chars ......... "map error"\
Invalid character in map ....... "map error"\
Unequal row lengths ............ "map error"\
Failed malloc .................. "map error"\
File open failure .............. "map error"\
\
After error, program continues with next file.\
\
------------------------------------------------------------\
9. ALGORITHM (BRUTE FORCE)\
------------------------------------------------------------\
For each coordinate (r, c):\
    size = 0\
    while inside map and no obstacles:\
        check bottom row and right column for obstacles\
        if clear:\
            size++\
        else:\
            break\
    if size > current_max:\
        update best (r, c, size)\
\
After scanning all cells:\
fill the best square with map->full\
\
Tie-breaking:\
Because scanning goes top-to-bottom and left-to-right,\
the first largest found automatically wins (topmost, then leftmost).\
\
------------------------------------------------------------\
10. COMPLEXITY\
------------------------------------------------------------\
Stage                     Time Complexity      Space Complexity\
---------------------------------------------------------------\
File Read and Parse        O(n)                O(n)\
Square Scanning (Brute)    O(n\'b3)               O(1)\
Filling and Printing       O(n\'b2)               O(1)\
---------------------------------------------------------------\
Total                     O(n\'b3)                O(n\'b2) (for map storage)\
\
------------------------------------------------------------\
11. MEMORY FLOW\
------------------------------------------------------------\
Action                      Allocated              Freed by\
------------------------------------------------------------\
ft_read_map()               raw_map                free(raw_map)\
ft_extract_map()            t_map, map->map[]      ft_free_map()\
solve_bsq()                 t_sol                  free(sol)\
append_content()            temp buffers           freed each iteration\
End of Program              all cleared            clean exit\
\
------------------------------------------------------------\
12. TESTING\
------------------------------------------------------------\
Simple test maps:\
\
ok.map\
------\
5.ox\
.....\
..o..\
.....\
.o...\
.....\
\
tiny.map\
---------\
1.ox\
.\
\
bad_header.map\
---------------\
x.ox\
.....\
\
bad_char.map\
-------------\
3.ox\
..a\
...\
...\
\
unequal.map\
------------\
3.ox\
.....\
....\
.....\
\
Commands to test:\
make\
./bsq ok.map\
./bsq ok.map bad_char.map\
cat ok.map | ./bsq\
\
Expected behavior:\
- Valid maps print solved grids.\
- Invalid maps print "map error".\
- Multiple files separated by a blank line.\
\
------------------------------------------------------------\
13. SAMPLE OUTPUT\
------------------------------------------------------------\
Input:\
9.ox\
...........................\
....o......................\
............o..............\
...........................\
....o......................\
...............o...........\
...........................\
......o..............o.....\
..o.......o................\
\
Output:\
.....xxxxxxx...............\
....oxxxxxxx...............\
.....xxxxxxxo..............\
.....xxxxxxx...............\
....oxxxxxxx...............\
.....xxxxxxx...o...........\
.....xxxxxxx...............\
......o..............o.....\
..o.......o................\
\
------------------------------------------------------------\
14. DEFENSE SUMMARY\
------------------------------------------------------------\
What the program does:\
Reads a map, validates it, finds the largest square that fits without obstacles,\
fills it with the full character, prints the result, and handles errors gracefully.\
\
Algorithm type:\
Brute-force scan (checks all positions and square sizes).\
\
Tie-breaking rule:\
Topmost first, then leftmost.\
\
Error handling:\
Prints "map error" and moves to next file.\
\
Complexity:\
Roughly O(n\'b3), acceptable for expected map sizes.\
\
Memory handling:\
All allocated memory is freed before exit.\
\
------------------------------------------------------------\
END OF README\
------------------------------------------------------------}