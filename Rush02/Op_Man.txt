# INSTRUCTION MANUAL — OPERATING THE PROGRAM (SEPARATE FROM README)

	A) Inputs and command forms


		1.	Using the default dictionary file

			Command: rush-02 12345
			Behavior: Loads dicts/numbers.dict, validates “12345”,
			prints “twelve thousand three hundred forty five”
			(based on your dictionary’s wording).


		2.	Using a custom dictionary

			Command: rush-02 path/to/my.dict 7000001
			Behavior: Loads the given file and uses its wording.
			If your dictionary defines “and” usage or hyphenation,
			the output reflects that.


		3.	What the dictionary must look like

			Format: one mapping per line
			Example lines:
			0: zero
			1: one
			10: ten
			11: eleven
			20: twenty
			100: hundred
			1000: thousand
			1000000: million


	Notes:
	• Only the first colon splits key and value.

	• Keys must be digits only; values are arbitrary non-empty text (trimmed).

	• Extra spaces around keys and values are allowed; trim_spaces removes them.

	• Empty lines or lines without a colon are ignored.



	B) What happens internally when you run it

		1.	Argument parsing (main.c)

			• If 1 argument: number only → use default dictionary path.

			• If 2 arguments: first is dictionary path, second is number.

			• Otherwise: print usage and exit non-zero.


		2.	Load dictionary (parse_dict.c)

			• slurp reads the file into memory.

			• pass1_count_pairs counts colon-bearing lines.

			• Allocate t_pair[count].

			• parse_lines_into_pairs fills pairs with ft_strdup’d key/val strings.

			• sort_pairs orders them (deterministic searches and predictable output).

			• On any failure, memory is freed and the program exits with error.


		3.	Validate number (num_validate.c)

			• Reject empty strings, non-digits, or numerically invalid formats you defined.

			• If invalid: free dict and exit with error.


		4.	Convert to words (convert_main.c and helpers)

			• Special case “0” prints value of key “0”.

			• Split digits from right into chunks of 3 (groups).

			• For each group from most significant to least:

				– If group is non-zero:

				· spell_hundreds handles 1–999 inside the group.

				· scale_for_group returns thousand/million/billion for group index.

				· spell_chunk_with_scale appends the scale term (except for group 0).

			• Spacing handled via write_space_if_needed so there are no extra spaces.
		

		5.	Cleanup (free_all.c)

			• free_dict frees all duplicated strings and the array.


	C) Expected outputs and errors

			• On success: the words are written to stdout followed by a newline (depending on your implementation).

			• On dictionary I/O or parse error: an error message (if you print one) and non-zero exit.

			• On invalid number: non-zero exit and possibly a message like “Error”.


	D) Extending or changing behavior
			
			• Different “and” rules (e.g., British “one hundred and five”):
			  implement an optional insert of “and” inside spell_hundreds when remainder exists;
			  add dictionary key for “and” if you want to make it data-driven.
			
			• Hyphenation (twenty-one):
			  either keep as dictionary values (e.g., 21: twenty-one) or implement logic
			  in spell_two to output “twenty one” or “twenty-one” based on a flag.

			• Larger scales: add keys and values in the dictionary
			  (1000000000: billion, 1000000000000: trillion, etc.)
			  and ensure scale_for_group maps them.


	E) Testing checklist

			• Small numbers: 0..20, tens, mixed 2-digit (21, 34, 99).

			• Hundreds: 100, 101, 110, 115, 342, 900.

			• Thousands+: 1,000; 10,005; 105,000; 1,234,567.

			• Very large: multiple groups, e.g., 987,654,321,000.

			• Dictionary edge cases: lines with extra spaces, empty lines,
			  missing lines for required keys (the output should still be predictable,
			  but missing keys will lead to lookup failures if your converter requires them).


	F) Troubleshooting

			• Norminette: keep functions ≤25 lines, declare vars at block start, avoid ternaries/for,
			  keep line length ≤80, and indent with tabs.
			
			• Undefined symbol errors at link time: ensure every function declared in rush02.h has
			  exactly one definition compiled into the target.

			• “call to undeclared function”: include rush02.h in any .c using the function;
			  ensure prototypes match (e.g., ft_strlen returns int in this project).
			
			• Empty or weird output: confirm dict_find returns non-NULL for all keys used
			  during conversion; verify dictionary contains required scale words and 0–19
			  and tens keys as needed.
			
			• Memory: if parse fails mid-way, parse_dict already frees; on success paths,
			  always call free_dict before exiting main.


	G) Minimal operator workflow

			1.	Place your dictionary at dicts/numbers.dict or pass a custom path on the command line.

			2.	Build with make re.

			3.	Run: rush-02 123456 or rush-02 my.dict 123456.

			4.	If you modify parsing or conversion, rerun Norminette and make re.

			5.	Commit early and often; test with a suite of representative inputs.



	1. Quick sanity test — rebuild & smoke test
		bash
			make re
			echo
			echo "🧩 BASIC CHECKS"
			./rush-02 0
			./rush-02 5
			./rush-02 13
			./rush-02 20
			./rush-02 100
			./rush-02 101
			./rush-02 219
			./rush-02 1005
			./rush-02 1234567

	Expected (based on standard numbers.dict):
			zero
			five
			thirteen
			twenty
			one hundred
			one hundred one
			two hundred nineteen
			one thousand five
			one million two hundred thirty four thousand five hundred sixty seven


	2. Mid-range dictionary coverage
		bash
			echo
			echo "🧮 MID-RANGE TESTS"
			./rush-02 999
			./rush-02 1000
			./rush-02 1001
			./rush-02 1010
			./rush-02 1100
			./rush-02 1000000
			./rush-02 1000001
			./rush-02 2003456

	Expected rough outputs:
			nine hundred ninety nine
			one thousand
			one thousand one
			one thousand ten
			one thousand one hundred
			one million
			one million one
			two million three thousand four hundred fifty six

	3. Large number stress tests
		bash
			echo
			echo "🚀 LARGE-NUMBER TESTS"
			./rush-02 1000000000
			./rush-02 1234567890
			./rush-02 987654321000

	(Ensure your dictionary defines 1000000000: billion, etc. or
	 the converter will return missing-word errors.)

	 4. Error & validation handling
		bash
			echo
			echo "🧾 ERROR / VALIDATION TESTS"
			./rush-02
			./rush-02 abc
			./rush-02 00123
			./rush-02 dicts/numbers.dict xyz
			./rush-02 nosuchdict.dict 12

		Expected: Error / invalid input / Dict Error (depending on your implementation)

	5. Custom dictionary test

		Create a minimal custom dictionary:
		cat > /tmp/mini.dict <<EOF
		0 : zero
		1 : one
		2 : two
		10 : ten
		100 : hundred
		1000 : thousand
		EOF

		Then test it:
		echo
		echo "🧠 CUSTOM MINI DICT TEST"
		./rush-02 /tmp/mini.dict 1200

		Expected output:
		one thousand two hundred

	6. Automated loop testing (optional)
		Run all 0–30 sequentially to ensure dictionary entries
		are consistent:
			echo
			echo "🧪 RANGE TEST 0–30"
			for n in $(seq 0 30); do
			printf "%3d -> " "$n"
			./rush-02 $n
			done

	7. Full dictionary audit (optional)
		Check if required keys exist:
			echo
			echo "⚙️ DICTIONARY AUDIT"
			for k in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 30 40 50 60 70 80 90 100 1000 1000000 1000000000; do
			printf "%s -> " "$k"
			grep -E "^[[:space:]]*$k[[:space:]]*:" dicts/numbers.dict || echo "MISSING"
			done

	8. One-liner to automate all tests and log results

			(
			make re &&
			echo "=== Rush02 Test Log ===" &&
			date &&
			echo &&
			for n in 0 1 13 19 20 42 100 105 219 999 1000 1005 1234567; do
				echo "----- $n -----"
				./rush-02 $n
			done
			) | tee rush02_test.log

			