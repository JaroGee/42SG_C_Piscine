/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Rush01.txt                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mgee <mgee@student.42singapore.sg>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/22 08:45:47 by mgee              +#+    #+#             */
/*   Updated: 2025/10/22 08:45:47 by mgee             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

What is Rush01 really about?

Imagine a 4×4 square like a tiny city block with 16 plots of land.
You’re told to build buildings on each plot.
The height of each building can only be 1, 2, 3, or 4 floors.
So each box will hold a number from 1 to 4, meaning the height of that building.

But here are the rules:

1. Each row (left to right) must have all four different numbers:
   1, 2, 3, 4 — no repeats.
   Think of it like sudoku rows. You can’t have two of the same number.

2. Each column (top to bottom) must also have all four different numbers.

3. Around the grid there are clues:
   Numbers that tell you how many buildings you can see 
   when looking from the side.


Example of “seeing buildings”

Imagine you’re standing on the left side of a row of buildings.

If the row is [2, 3, 1, 4]:

1. From the left you first see building 2.
2. Next building is 3, which is taller → you see it too (2 buildings so far).
3. Next building 1 is shorter than 3 → you can’t see it.
4. Next building 4 is taller than 3 → you see it.
So from the left, you see 3 buildings.

From the right, you look the other way: [4, 1, 3, 2]

1. You first see 4 (it’s the tallest possible)
→ you can’t see anything behind it.
2. So from the right, you see 1 building.

This is how the “clues” work.
Each side (top, bottom, left, right) 
Gives you a number that tells how many buildings are visible from that direction.


Input format (what the computer receives)

We give the program one big string of 16 numbers, separated by spaces.

1. 4 clues for the top
2. 4 clues for the bottom
3. 4 clues for the left
4. 4 clues for the right

so something like this: 4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2

the order is very important:

| Position | What it means                |
| -------- | ---------------------------- |
| 1–4      | top clues for columns 1–4    |
| 5–8      | bottom clues for columns 1–4 |
| 9–12     | left clues for rows 1–4      |
| 13–16    | right clues for rows 1–4     |


What the program must do?

1. Read those 16 numbers.
If there aren’t exactly 16, or if any aren’t between 1 and 4 → print "Error".

2. Try to fill the 4×4 grid with numbers 1–4 in every box.
    - No duplicates in rows or columns.
    - Clues must match what you “see” from each side.

3. Print the first valid arrangement.
    - Each row on one line, numbers separated by spaces.

4. If nothing works, or input is invalid → print "Error".


How the code is organized?

when we code something big, we split it into smaller pieces.
each file here does a small, clear job.


rush.h — the “instruction list”

What it does:
Think of it like the table of contents of your project.
It tells all the other files what functions exist and what they do,
so the files can “talk” to each other.

Inside it:
	•	We include only what’s allowed:
	•	<unistd.h> → lets us use write() to print things.
	•	<stdlib.h> → lets us use malloc() and free()
        (even though we don’t really need them for 4×4).
	•	Then we list all our functions — things like:
	•	printing characters (ft_putchar)
	•	reading input (parse_clues_4x4)
	•	checking duplicates
	•	counting visibility
	•	solving the puzzle (solve_cell)

So rush.h doesn’t do anything; 
it just tells the rest of the program what parts exist.

Analogy: it’s like the cover page of a manual that lists all chapters.


---


main.c — the “manager”

What it does:
This file is the brain that tells everyone what to do and in what order.
It doesn’t solve the puzzle itself — it just sets everything up.

Let’s walk through it like a story:

	1.	the program starts here (int main(...)).

	2.	we make space to store:
	    •	the 16 clues → int clues[16];
	    •	the 4×4 grid → int grid[4][4];

	3.	we check the input:
	    •	if the number of arguments isn’t exactly 2 → print "Error".
	    •	if parsing those clues fails → print "Error".

	4.	we “clean the grid” (set everything to 0).

	5.	we call the solver
        this is the brain that actually tries all possibilities.

	6.	if the solver succeeds → print the grid.

	7.	if not → print "Error".

Analogy:
main.c is like the game host who checks that players are ready,
sets the board, and then lets the puzzle solver do their thing.


---


io.c — how the program “talks”

What it does:
This file handles printing.
Because we can’t use printf, we use write() directly.

Functions:
	•	ft_putchar — prints 1 letter or digit.
	•	ft_putstr — prints a word or message letter by letter.
	•	ft_putnbr — prints a number (1–4).
	•	print_grid — prints the whole board nicely, row by row.

Analogy:
This is like the announcer who reads out the answers clearly for the audience.


---


parse.c — reading the clues correctly

What it does:
It takes the long string "4 3 2 1 1 2 2 2 ..."
and splits it into 16 real numbers (not characters).

Let’s break it down:
	•	is_space() — checks if a character is a space or tab.
(helps skip gaps)
	•	is_digit() — checks if a character is 0–9.
	•	skip_spaces() — moves past any extra spaces.
	•	read_token_4x4() — reads one valid number (must be 1–4).
if it’s invalid → returns -1 (meaning “error”).
	•	parse_clues_4x4() — calls read_token_4x4() 16 times to fill all clues.

If it finds anything wrong (too few, too many, or invalid numbers),
it returns 0 (false) so main.c can print "Error".

Analogy:
This is like a ticket counter that checks 16 tickets
all must be valid and no extras allowed.


---


checks.c — checking for duplicates

What it does:
After we put a number in a cell, we must make sure it
doesn’t appear twice in the same row or column.

Let’s say we’re filling the second row.
If that row already has “2”, we can’t add another “2”.
Same rule for columns.

We do this with:
	•	row_has_dup() — checks for repeats in a row up to a certain column.
	•	col_has_dup() — checks for repeats in a column up to a certain row.

If it finds a duplicate, it says “no” right away — we stop going down that path.

Analogy:
Imagine you’re making a list of team members — everyone’s name must be unique.
If you see the same name twice, you erase the last one and try again.


---


views.c — counting what you “see”

What it does:
When a row or column is finished, we check if the clues around it make sense.

Example:
if the clue on the left says “2”, and we can see 2 buildings 
when we look from the left, perfect.
if we see 3 buildings, something’s wrong — we’ll reject that arrangement.

This file contains:
	•	a function to count visible buildings from left to right
	•	another to count visible buildings from right to left
	•	and two checker functions:
	•	check_row_views()
	•	check_col_views()

Each one takes the row or column and compares the count with the clue.

Analogy:
Like a person standing on the sidewalk counting buildings they can see.


---


solve.c - the brain of the operation

What it does:
This is where the puzzle is actually solved
by trying numbers and backtracking when things don’t fit.

Think of it like this:
	1.	Start at the first cell (top-left).

	2.	Try putting number 1.
	    •	if it breaks the rules (duplicate or visibility) → erase and try 2.
	    •	if 2 doesn’t work → try 3.
	    •	if 3 doesn’t work → try 4.
	    •	if none work → go back one step and change the previous cell’s number.

	3.	Continue this pattern until the whole grid is filled correctly.

	4.	If the entire grid is filled with valid numbers → done! print it.

We call this technique backtracking
because you literally “backtrack” (go backward) when you hit a dead end.

Analogy:
It’s like a maze:
You walk forward until you hit a wall.
Then you go back to the last intersection and try a different path.


How the whole program flows

1. You start the program and type the clues.

2. main.c checks if the clues are valid using parse.c.

3. The grid is cleared (all zeros).

4. The solver (solve.c) begins filling the grid:
	•	It uses checks.c to avoid duplicates.
	•	It uses views.c to make sure clues match.

5. When a full valid grid is found, io.c prints it.


| Step | File       | What happens                             |
| ---- | ---------- | ---------------------------------------- |
| 1    | `main.c`   | Reads input, prepares grid               |
| 2    | `parse.c`  | Converts the input string into 16 clues  |
| 3    | `solve.c`  | Starts recursive backtracking            |
| 4    | `checks.c` | Rejects duplicates                       |
| 5    | `views.c`  | Enforces visibility clues                |
| 6    | `io.c`     | Prints the final valid grid              |
| 7    | `rush.h`   | Makes all functions visible across files |


---


How to explain to evaluator:

“We split the project into logical modules.
main.c handles input/output and error checks.
parse.c validates clues.
solve.c runs the recursive backtracking.
checks.c ensures no duplicates.
views.c checks visibility rules.
io.c handles display using only write().
And rush.h keeps everything connected and norm-friendly.”