/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   views.txt                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mgee <mgee@student.42singapore.sg>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/22 09:02:16 by mgee              +#+    #+#             */
/*   Updated: 2025/10/22 09:02:16 by mgee             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

Line by line explanation:

#include "rush.h"

We import the project’s function declarations and allowed headers.

---

static int	count_visible_forward(const int *v, int len)

Define a helper that counts how many buildings you can see
when you scan a row/column from the front (e.g., left→right, or top→bottom).

Think: walking along a street and counting each time a taller building appears.

---

int	i; int	max; int	cnt;

•	i = position we’re looking at

•	max = tallest building we’ve seen so far

•	cnt = how many buildings we’ve seen

---

i = 0; max = 0; cnt = 0;

Start at the first spot. 
Haven’t seen any buildings yet, so tallest is 0, count is 0.

---

while (i < len)
{
	if (v[i] > max)
	{
		max = v[i];
		cnt++;
	}
	i++;
}
return (cnt);


Walk through all heights:

	•	If the current building is taller than any seen before, we see it → bump cnt, and update max.
	
    •	Keep going until the end.
	
    •	Return how many we saw.

Analogy: you’re filming a parade. Each float that’s taller than the last becomes visible on camera.

---

static int	count_visible_backward(const int *v, int len)

Same idea, but scanning from the back (e.g., right→left, or bottom→top).

---

int i = len - 1; int max = 0; int cnt = 0;

Start at the last position, tallest=0, count=0.

---

while (i >= 0)
{
	if (v[i] > max)
	{
		max = v[i];
		cnt++;
	}
	i--;
}
return (cnt);


Walk backwards. Count and update the same way.
Return the count at the end.

Why both?

Because rows have left and right clues;
columns have top and bottom clues.

---

int	check_row_views(int grid[4][4], int r, int left, int right)

Check if row r matches the left and right clues.

---

int tmp[4]; int c = 0;
while (c < 4) { tmp[c] = grid[r][c]; c++; }

Copy that row’s four numbers into a small array tmp.
(We copy to keep the counting helpers clean and reusable.)

---

if (count_visible_forward(tmp, 4) != left) return (0);
if (count_visible_backward(tmp, 4) != right) return (0);
return (1);

•	Count visible from the left. If it’s not exactly left, fail (return 0).

•	Count visible from the right. If it’s not exactly right, fail.

•	If both match, success (return 1).

---

int	check_col_views(int grid[4][4], int c, int top, int bottom)

Same as row check, but for column c with top and bottom clues.

---

int tmp[4]; int r = 0;
while (r < 4) { tmp[r] = grid[r][c]; r++; }

Copy column values into tmp.

---

if (count_visible_forward(tmp, 4) != top) return (0);
if (count_visible_backward(tmp, 4) != bottom) return (0);
return (1);


Validate top and bottom counts. Return 1 only if both match.

Why do we call these only when a row/column is finished?
Because visibility counts only make sense with all 4 numbers placed.
(We check this in solve.c using the “if last cell in the row/column” helpers.)