/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.txt                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mgee <mgee@student.42singapore.sg>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/22 09:14:24 by mgee              +#+    #+#             */
/*   Updated: 2025/10/22 09:14:24 by mgee             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

Line by line explanation:

#include "rush.h"

We import our “table of contents” so the compiler
knows about our functions and allowed headers.

---

static int	is_space(char c)
{
	return (c == ' ' || c == '\t');
}

Is this a space? if yes, return 1 (true); else 0 (false).
we treat tab like a space too.

---

static int	is_digit(char c)
{
	return (c >= '0' && c <= '9');
}

Is this a digit character? (like ‘3’)
note: this checks the character, not the number itself.

---

static const char	*skip_spaces(const char *s)
{
	while (*s && is_space(*s))
		s++;
	return (s);
}

Walk past any spaces until we hit a non-space or the end of the string.
returns the updated pointer.

Analogy: move your finger across empty gaps until you touch the next ticket.

---

/* read exactly one token '1'..'4'; return -1 on error */
static int	read_token_4x4(const char **ps)
{
	const char	*s;
    

We’ll read one number from the text.
if anything goes wrong, return -1 to signal “error”.

---

	s = skip_spaces(*ps);

Start by skipping any spaces where we currently are.

---

	if (!*s || !is_digit(*s) || *s < '1' || *s > '4')
		return (-1);

Reject if:
	•	we reached the end of the string,
	•	or the next char isn’t a digit,
	•	or it’s a digit, but not 1..4 (e.g., ‘0’ or ‘7’).

---

	*ps = s + 1;

We successfully read one digit, so we advance the caller’s pointer by 1.

---

	return ((int)(*s - '0'));

Convert the character (e.g., ‘3’) to the integer 3 and return it.

---

int	parse_clues_4x4(const char *s, int out16[16])
{
	int	i;
	int	val;

Main parsing function: read exactly 16 valid tokens into out16.

---

	i = 0;
	while (i < 16)
	{
		val = read_token_4x4(&s);
		if (val == -1)
			return (0);
		out16[i] = val;
		i++;
		s = skip_spaces(s);
	}

Loop 16 times:
•	try to read one token;
•	if it fails → whole parse fails (return 0);
•	store the number in out16[i];
•	move past any spaces before the next token.

---

	s = skip_spaces(s);
	return (*s == '\0');
}

After 16 numbers, allow only spaces and then end of string.
if there’s extra junk (like “x” or another number), return false.

Analogy: the ticket checker must see exactly 16 real tickets,
then nothing else but blank space.

---

Imagine a maze with 16 rooms arranged in a 4×4 grid.
You must place a flag in each room with a number 1..4.

Rules:
	•	In every row, all flags must be different.

	•	In every column, all flags must be different.

	•	When a row finishes, a guard on the left and right checks
        if the skyline looks correct (visibility).

	•	When a column finishes, a guard on the top and bottom checks it too.

How you move:
	1.	Start in room 0 (top-left).

	2.	Try flag “1”. 
        If the guards don’t complain (no duplicates; partial okay),
        step into next room.

	3.	Keep going.
        If you hit a room where no flag works (guards complain for every choice),
        walk backwards to the previous room, change that room’s flag, and continue.

	4.	If you walk past the last room (room 16),
        you’ve placed all flags correctly — you’ve escaped the maze.

One-liner you can say in eval:

“Backtracking = try → check → go forward;  if stuck, go backward and try the next option.”

---

Quick recap you can read to your evaluator

	•	What’s the puzzle? A 4×4 grid of buildings (1..4). 
        Rows and columns can’t repeat numbers.
        Side clues say how many buildings you can see from each edge.

	•	How do we read input? We parse exactly 16 numbers (1..4)
        in the order: top(4), bottom(4), left(4), right(4). 
        Anything else → Error.

	•	How do we solve it? 
        Backtracking.
        At each cell we try 1..4,
        reject duplicates immediately,
        and check visibility only when a line is complete.
        If stuck, undo and try another number.

	•	How do we print? Using write() only (no printf).
        Rows are space-separated numbers with newlines.

	•	Files quick roles:
        main.c manages;
        parse.c validates clues;
        checks.c stops duplicates;
        views.c enforces visibility;
        solve.c backtracks;
        io.c prints;
        rush.h connects everything.