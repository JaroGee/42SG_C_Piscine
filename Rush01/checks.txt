/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checks.txt                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mgee <mgee@student.42singapore.sg>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/22 09:07:58 by mgee              +#+    #+#             */
/*   Updated: 2025/10/22 09:07:58 by mgee             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

Line by line explanation:

#include "rush.h"

We import our function declarations and allowed headers, so this file can call things (and be called) correctly.

---

Function 1 — row_has_dup(...)

Goal:
Look at one row (row r) from column 0 up to column upto_c,
and say if any number repeats.

Why “prefix”?

Because during solving, we fill the row left→right.
We only need to examine the part we’ve touched so far.

---

int	row_has_dup(int grid[4][4], int r, int upto_c)

•	We’re checking row r, across columns 0..upto_c.

---

int	used[5];
int	c;
int	v;

•	used is a tiny checklist for numbers 1..4 (index 0 is ignored).
•	c is our column counter.
•	v will hold the value we read from the grid.

---

used[0] = 0;
used[1] = 0;
used[2] = 0;
used[3] = 0;
used[4] = 0;

Set every “seen?” flag to 0 (meaning “not seen yet”).

Analogy:
Imagine five empty boxes labeled 0..4.
We’ll tick the box for a number once we see it (for 1..4 only).

---

c = 0;
while (c <= upto_c)
{
	v = grid[r][c];

Start at the first column in that row; read the current cell’s value.

---

	if (v != 0)

Skip empty cells (0 means not filled yet). Only check duplicates for real numbers (1..4).

---

	{
		if (used[v])
			return (1);
		used[v] = 1;
	}


•	If we already marked this number as seen → duplicate found → return 1 (means “yes, dup exists”).

•	Otherwise mark used[v] = 1 so we remember we have this number now.

---

	c++;
}
return (0);

•	Move to next column, repeat.
•	If we finish the loop without finding a duplicate → return 0 (no duplicates).

Analogy:
You’re taking attendance. If a name (number) appears twice, raise a red flag immediately.

---

Function 2 — col_has_dup(...)

Goal:
Same idea, but vertical: look at column c, rows 0..upto_r.

---

int	col_has_dup(int grid[4][4], int c, int upto_r)

•	We’re checking column c from the top row down to upto_r.

---

int	used[5];
int	r;
int	v;

•	Same checklist for 1..4, now with a row counter r.

---

used[0] = 0;
used[1] = 0;
used[2] = 0;
used[3] = 0;
used[4] = 0;
r = 0;
while (r <= upto_r)
{
	v = grid[r][c];
	if (v != 0)
	{
		if (used[v])
			return (1);
		used[v] = 1;
	}
	r++;
}
return (0);


Exactly the same logic as row check, just moving down the column.

Analogy:
Another attendance check, but for the vertical list.

---

Why these checks matter (big picture)

	•	We call these right after placing a number.
	•	If a duplicate appears, we stop immediately
		no need to waste time checking visibility or going deeper into recursion.
	•	This saves tons of time because most wrong paths get cut off early.

Simple story:
Don’t keep building a tower if the foundation is already wrong.

---

Clue indexing (where each clue lives)

clues[0]  clues[1]  clues[2]  clues[3]      <-- TOP of columns 0..3
clues[4]  clues[5]  clues[6]  clues[7]      <-- BOTTOM of columns 0..3
clues[8]  clues[9]  clues[10] clues[11]     <-- LEFT of rows 0..3
clues[12] clues[13] clues[14] clues[15]     <-- RIGHT of rows 0..3

When the solver finishes:
•	a row r → it checks LEFT = clues[8 + r] and RIGHT = clues[12 + r].
•	a column c → it checks TOP = clues[c] and BOTTOM = clues[4 + c].

---

Data flow (who calls who)

main.c
  → parse_clues_4x4(...)      // from parse.c (validate the 16 numbers)
  → init_grid(...)            // set all cells to 0
  → solve_cell(...)           // from solve.c (backtracking)
       ↳ row_has_dup(...)     // from checks.c
       ↳ col_has_dup(...)     // from checks.c
       ↳ check_row_views(...) // from views.c
       ↳ check_col_views(...) // from views.c
  → print_grid(...)           // from io.c
